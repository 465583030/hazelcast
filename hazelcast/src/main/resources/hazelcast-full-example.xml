<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright (c) 2008-2016, Hazelcast, Inc. All Rights Reserved.
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~ http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<!--
This is a full example hazelcast.xml including all the configuration elements and attributes of Hazelcast.
To use this, rename it to hazelcast.xml and place it in the directory where you start Hazelcast.
Please see the schema to learn how to configure Hazelcast at https://hazelcast.com/schema/config/hazelcast-config-3.6.xsd 
or the Reference Manual at https://hazelcast.org/documentation/.
-->
<hazelcast xsi:schemaLocation="http://www.hazelcast.com/schema/config hazelcast-config-3.6.xsd"
           xmlns="http://www.hazelcast.com/schema/config"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<!--
    You can use the <import> element to load different Hazelcast declarative configuration files you prepared.
    You can import as many XML files as you want and hence compose your Hazelcast configuration
    out of those XML files. If you want to use the <import> element, it should be placed at the top of your
    Hazelcast XML file right after the <hazelcast> element. It has the required attribute "resource".
    
    Below is an example where the configuration files you want to include are located at your 
    Hazelcast working directory:
    <import resource="your-configuration-file.xml"/>
    
    Below are examples showing that you can also give a classpath or filesystem location:
    <import resource="file:///etc/hazelcast/your-configuration-file-1.xml"/> 
    <import resource="classpath:your-configuration-file-2.xml"/> 
    
    Below is an example showing that you can use property placeholders:
    <import resource="${environment}-your-configuration-file.xml"/>
    
-->    
    <import resource="your-configuration-XML-file"/>
<!--
    Specifies the name and password for a cluster group you create.
    Cluster groups allow you to create separate sub-clusters within your Hazelcast cluster to create a simple security
    and they are also used for the WAN Replication feature. 
-->
    <group>
        <name>dev</name>
        <password>dev-pass</password>
    </group>
<!--
    If you have an Enterprise or Enterprise HD license, you should type it here.
    Note that you can also set your license key programmatically; please refer to 
    http://docs.hazelcast.org/docs/latest/manual/html-single/index.html#setting-the-license-key
-->    
    <license-key>Your Hazelcast Enterprise or Enterprise HD License Key</license-key>
<!--
    When Hazelcast instances are created, they are put in a global registry with their creation names.
    <instance-name> elements gives you the ability to get a specific Hazelcast instance from this registry
    by giving the instance's name.
-->    
    <instance-name>hzInstance1</instance-name>
<!--
    Configuration for Hazelcast's Management Center.
    The value for the element <management-center> is the URL where you deploy the Management Center.
    It has two optional attributes:
    * enabled: 
              Set to true to be able to use the Management Center. Its default is false.
    * update-interval: 
              The time frequency (in seconds) for which Management Center will take information from Hazelcast cluster. Its default is 3 seconds.
              Hazelcast's Open Source edition provides the Management Center with monitoring at most 2 members in your cluster.
              To use it for more members, you need to have either a Management Center, Hazelcast Enterprise or Hazelcast Enterprise HD license. 
-->        
    <management-center enabled="true" update-interval="2">http://localhost:8080/mancenter</management-center>
<!--
    Let's you to add properties to some of the Hazelcast elements used to configure some of the Hazelcast modules. 
    You can define the name and value of your property using the sub-element <property>.
    You can use <properties> for the following Hazelcast configuration elements:
    * <discovery-strategy>
    * <map-store>
    * <queue-store>
    * <ssl>
    * <service>
    * <login-module>
    * <security-object>
    * <socket-interceptor>
-->        
    <properties>
    	<property name="your-property">Value of the property</property>
    </properties>
<!--
    Configuration for Hazelcast's WAN Replication feature. This feature is available only in Hazelcast Enterprise.
    
    It has two attributes:
    * name: 
            Name of your WAN Replication. This name is referenced in IMap or ICache configuration when you add WAN Replication
            for these data structures (using the element <wan-replication-ref> in the configuration of IMap or ICache). Please see 
            the <map> and <cache> configuration descriptions in this XML.
    * snapshot-enabled: 
            This attribute is valid when you use `WanBatchReplication` as the WAN Replication implementation. When
            set to true, only the latest events (based on key) are selected and sent to the target cluster in a batch.
    
    It has the following elements:
    * <target-cluster>: 
            Specifies the target cluster to which the events will be replicated. It has the group-name and
            group-password attributes. These attributes correspond to the <name> and <password> sub-elements, respectively, defined 
            in the target cluster's <group> element. Please see the <group> configuration description in this XML.
    * <replication-impl>: Name of the class implementation for WAN Replication. There are two values:
    	- WanNoDelayReplication: 
    	    It sends replication events to the target cluster as soon as they are generated.
    	- WanBatchReplication: 
    	    It waits until a batch size is reached or a delay time is passed.
    	    Please see the <batch-size> and <batch-max-delay-millis> configuration descriptions below.
    * <end-points>: 
            IP addresses of the target cluster members for which the WAN replication is implemented. These addresses
            are given using the <address> sub-elements.
    * <batch-size>: 
            This element is valid when you use `WanBatchReplication` as the WAN Replication implementation. It is 
            used to change the maximum size of events that are sent to the target cluster in a single batch. The batch of events is not 
            send until this size is reached. Its default is 500.
    * <batch-max-delay-millis>: 
            This element is valid when you use `WanBatchReplication` as the WAN Replication implementation. If the 
            number of events generated does not reach the <batch-size>, they are sent to the target cluster after a certain 
            amount of time is passed. You can set this duration in milliseconds using this element. Its default is 1000 milliseconds.
    * <response-timeout-millis>: 
            After a replication event is sent to the target cluster, the source member waits for a confirmation 
            that tells the event has reached the target. If confirmation is not received for a period of <response-timeout-millis>, 
            the event is resent to the target cluster. Its default is 60000 milliseconds.
    * <queue-capacity>: 
            Size of the queue of events. Its default value is 10000. You might exceed the queue size so that the 
            oldest, not yet replicated, updates might get lost. Therefore, if you have a large rate of put/update/remove operations,
            you should increase <queue-capacity>.
    * <queue-full-behavior>: 
            Policy to be applied when WAN Replication event queues are full. There are two values:
    	    - DISCARD_AFTER_MUTATION: 
    	          The new WAN events generated are dropped and not replicated to the target cluster.
	    - THROW_EXCEPTION: 
	          The WAN queue size is checked before each supported mutating operation If one the queues of target 
	          cluster is full, WANReplicationQueueFullException is thrown and the operation is not allowed.
    * <acknowledge-type>: 
            Acknowledgment type for each target cluster when the events are replicated. There are two values:
    	    - ACK_ON_RECEIPT: 
    	          Means that events are received by the target cluster successfully. It does not guarantee that 
    	          the received event is actually applied, but it is faster.
	    - ACK_ON_OPERATION_COMPLETE: 
	          This option guarantees that the event is received by the target cluster and it is applied. 
	          It is more time consuming, but it is the best way if you have strong consistency requirements.
-->        
    <wan-replication name="my-wan-cluster-batch" snapshot-enabled="false">
        <target-cluster group-name="nyc" group-password="nyc-pass">
            <replication-impl>
                com.hazelcast.enterprise.wan.replication.WanBatchReplication
            </replication-impl>
            <end-points>
                <address>10.3.5.1:5701</address>
                <address>10.3.5.2:5701</address>
            </end-points>
            <batch-size>1000</batch-size>
            <batch-max-delay-millis>2</batch-max-delay-millis>
            <response-timeout-millis>70000</response-timeout-millis>
            <queue-capacity>15000</queue-capacity>
            <queue-full-behavior>DISCARD_AFTER_MUTATION</queue-full-behavior>
            <acknowledge-type>ACK_ON_OPERATION_COMPLETE</acknowledge-type>
        </target-cluster>
    </wan-replication>
<!--
    Configuration to build your Hazelcast's network; includes port, interface, discovery mechanism, SSL, 
    encryption, etc. configurations. Parent configuration element is <network> and it includes the following sub-elements:
    
    * <public address>:  
            This optional element overrides the public address of a member and it is useful when 
            you have a private cloud. Normally, a member selects its socket address as its public address. But behind a NAT, 
            two members may not be able to see/access each other. In this case, you can set their public addresses to their 
            defined addresses on NAT. The value should be given in the format "host IP address:port number".
    * <port>: 
            Specifies the ports that Hazelcast will use to communicate between cluster members. It is optional and 
            its default value is 5701. It has the following attributes:
    	    - port-count: 
    	          By default, Hazelcast will try 100 ports to bind (i.e. the ports between 5701 and 5801). You can choose to 
    	          change the port count in the cases like having large instances on a single machine or willing to have only a few 
    	          ports to be assigned. It is optional and its default value is 100.
    	    - auto-increment:
    	          By default, Hazelcast tries to find a port by automatically incrementing the port numbers. If you 
    	          don't want this (you want to use a specific port), set this attribute's value to false. If it is 
    	          set to false, the port-count attribute is ignored. It is optional and its default value is true.
    	    Examples:
    	    Below example looks for ports between 5701 and 5721, incrementing the ports starting from 5701.	
    	    <port port-count="20">5701</port>
    	    Below example forces Hazelcast to use only the port 5701.
    	    <port auto-increment="false">5701</port>
    * <outbound-ports>:
	    By default, Hazelcast lets the system pick up an ephemeral port during socket bind operation. But security 
	    policies/firewalls may require you to restrict outbound ports to be used by Hazelcast-enabled applications. 
	    You can specify these ports using <ports> under the element <outbound-ports>. You can give a single port number,
	    comma separated multiple ports or port ranges. See the example below.
	    <outbound-ports>
               <ports>33000-35000</ports>
               <ports>37000,37001,37002,37003</ports> 
               <ports>38000,38500-38600</ports>
            </outbound-ports>
    * <reuse-address>:
    	    If you set this to true, Hazelcast will use the same port when you restart a member right after you shut it down.
    	    It is optional and its default value is false.
    * <join>:
    	    This configuration lets you to choose a discovery mechanism that Hazelcast will use to form a cluster. 
    	    Hazelcast can find members by multicast, TCP/IP lists and in the clouds supported by jclouds API. The following
    	    are the elements of <join>:
    	    - <multicast>:
		    Set its "enabled" attribute to true for discovery by multicast. It has the following sub-elements
		    to fine tune the multicast discovery.
		    - <multicast-group>:
		    			Specifies multicast group IP address when you want to create clusters within 
		                        the same network. Its default value is 224.2.2.3.
		    - <multicast-port>: 
		    			Specifies the multicast socket port that the Hazelcast member listens to and 
		                        sends discovery messages through. Its default value is 54327.
		    - <multicast-time-to-live>: 
		    			Time-to-live value for multicast packets sent out to control the scope of multicasts.
		    - <multicast-timeout-seconds>: 
		    			Only when the members are starting up, this timeout (in seconds) specifies the 
		    			period during which a member waits for a multicast response from another node. 
		    			For example, if you set it as 60 seconds, each node will wait for 60 seconds until a 
		    			leader node is selected. Its default value is 2 seconds.
		    - <trusted-interfaces>: 
		    			Includes IP addresses of trusted members. When a node wants to join to the cluster, 
		    			its join request will be rejected if it is not a trusted member. 
		    			You can give an IP addresses range using the wildcard (*) on the last digit of 
		    			IP address (e.g. 192.168.1.* or 192.168.1.100-110).
    	    - <tcp>:
		    Set its "enabled" attribute to true for discovery by TCP/IP. It has the following sub-elements
		    to fine tune the multicast discovery.
		    - <required-member>:
		    			IP address of the required member. Cluster will only formed if the member with this IP address is found.
		    - <member>:
		    			IP address(es) of one or more well known members. Once members are connected to these well known ones, 
		    			all member addresses will be communicated with each other. You can also give comma separated IP addresses 
		    			using the <members> element.
		    - <connection-timeout-seconds>:
		    			Defines the connection timeout. This is the maximum amount of time Hazelcast is going to try to connect 
		    			to a well known member before giving up. Increasing this value is recommended if you have many IPs listed and 
		    			the members cannot properly build up the cluster. Its default value is 5.
    	    - <discovery-strategies>:
		    Set its "enabled" attribute to true for discovery in a jclouds backed cloud. You also need to set the
		    value of "hazelcast.discovery.enabled" property to true. See the description of <properties> element
		    to learn how to do this.
		    You can define multiple discovery strategies using the <discovery-strategy> sub-element and its 
		    properties. Please refer to 
		    http://docs.hazelcast.org/docs/3.6/manual/html-single/index.html#discovering-members-with-jclouds
		    to see the properties you can use.
		    The following is an example for EC2 cloud.
		    <discovery-strategies>
        		<discovery-strategy class="com.hazelcast.jclouds.JCloudsDiscoveryStrategy" enabled="true">
          		  <properties>
           		    <property name="provider">aws-ec2</property>
           		    <property name="identity">AWS_IDENTITY</property>
           		    <property name="credential">AWS_CREDENTIAL</property>
          		  </properties>
        		</discovery-strategy>
    		    </discovery-strategies>
    * <interfaces>:
    	    Specifies which network interfaces Hazelcast should use. You need to set its "enabled" attribute
    	    to true to be able use your defined interfaces. You can define multiple interfaces
    	    using its <interface> sub-element. By default, it is disabled.
    * <ssl>:
    	    Lets you to configure SSL using the SSL context factory. This feature is available only in Hazelcast
    	    Enterprise. To be able to use it, the encryption should NOT be enabled and you should first implement the 
    	    your SSLContextFactory class. Its configuration contains the factory class and SSL properties. By default, it is
    	    disabled. The following is an example:
    	    <ssl enabled="true">
      		<factory-class-name>
          	    com.hazelcast.nio.ssl.BasicSSLContextFactory
      		</factory-class-name>
      		<properties>
        	    <property name="keyStore">keyStore</property>
        	    <property name="keyStorePassword">keyStorePassword</property>
        	    <property name="keyManagerAlgorithm">SunX509</property>
        	    <property name="trustManagerAlgorithm">SunX509</property>
        	    <property name="protocol">TLS</property>
      		</properties>
    	    </ssl>
    * <socket-interceptor>:
    	    Lets you to add custom hooks to join and perform connection procedures (like identity checking using Kerberos, etc.).
    	    This feature is available only in Hazelcast Enterprise. To be able to use it, you should first implement the 
    	    MemberSocketInterceptor (for members joining to a cluster) or SocketInterceptor (for clients connecting to a member) class. 
    	    Its configuration contains the class you implemented and socket interceptor properties. By default, it is
    	    disabled. The following is an example:
    	    <socket-interceptor enabled="true">
      		<class-name>
      		    com.hazelcast.examples.MySocketInterceptor
      		</class-name>
      		<properties>
        	   <property name="kerberos-host">kerb-host-name</property>
        	   <property name="kerberos-config-file">kerb.conf</property>
      		</properties>
	    </socket-interceptor>
    * <symmetric-encryption>:
    	    Lets you to encrypt the entire socket level communication among all Hazelcast members.
    	    This feature is available only in Hazelcast Enterprise.  Its configuration contains the encryption properties and
    	    the same configuration must be placed to all members. By default, it is disabled. The following is an example:
    	    <symmetric-encryption enabled="true">
	       <algorithm>PBEWithMD5AndDES</algorithm>
	       <salt>thesalt</salt>
	       <password>thepass</password>
	       <iteration-count>19</iteration-count>
	    </symmetric-encryption>
-->        
   <network>
        <public-address>11.22.33.44:5555</public-address>
        <port auto-increment="true" port-count="100">5701</port>
        <outbound-ports>
            <ports>34500</ports>
        </outbound-ports>
        <reuse-address>false</reuse-address>
        <join>
            <multicast enabled="true">
                <multicast-group>224.2.2.3</multicast-group>
                <multicast-port>54327</multicast-port>
            </multicast>
            <tcp-ip enabled="false">
                <interface>127.0.0.1</interface>
            </tcp-ip>
            <discovery-strategies>
              <discovery-strategy ... />
            </discovery-strategies>
        </join>
        <interfaces enabled="true">
            <interface>10.10.1.*</interface>
        </interfaces>
        <ssl enabled="false" />
        <socket-interceptor enabled="false" />
        <symmetric-encryption enabled="false" />
    </network>
<!--
    Configuration for the partition groups you create. You can enable it and specify the type using the "enabled" and
    "group-type" attributes. For CUSTOM type, you can define groups using its <member-group> and <interface> sub-elements.
    You can group the members with one of the following types:
    * HOST_AWARE: 
    	Members sharing the same network interface are grouped together. All members on the same host will be a 
    	single partition group.
    * CUSTOM: 
    	You can add different and multiple members to a group.
    * PER_MEMBER: 
    	Each member is a group of its own and primary/backup partitions are distributed randomly. This
-->
    <partition-group enabled="true" group-type="CUSTOM">
	<member-group>
	   <interface>10.10.0.*</interface>
	   <interface>10.10.3.*</interface>
	   <interface>10.10.5.*</interface>
	</member-group>
	<member-group>
	   <interface>10.10.10.10-100</interface>
	   <interface>10.10.1.*</interface>
	   <interface>10.10.2.*</interface>
	</member-group
    </partition-group>
<!--
    . 
-->
    <executor-service name="default">
        <pool-size>16</pool-size>
        <!--Queue capacity. 0 means Integer.MAX_VALUE.-->
        <queue-capacity>0</queue-capacity>
    </executor-service>
    <queue name="default">
        <!--
            Maximum size of the queue. When a JVM's local queue size reaches the maximum,
            all put/offer operations will get blocked until the queue size
            of the JVM goes down below the maximum.
            Any integer between 0 and Integer.MAX_VALUE. 0 means
            Integer.MAX_VALUE. Default is 0.
        -->
        <max-size>0</max-size>
        <!--
            Number of backups. If 1 is set as the backup-count for example,
            then all entries of the map will be copied to another JVM for
            fail-safety. 0 means no backup.
        -->
        <backup-count>1</backup-count>

        <!--
            Number of async backups. 0 means no backup.
        -->
        <async-backup-count>0</async-backup-count>

        <empty-queue-ttl>-1</empty-queue-ttl>
    </queue>
    <map name="default">
        <!--
           Data type that will be used for storing recordMap.
           Possible values:
           BINARY (default): keys and values will be stored as binary data
           OBJECT : values will be stored in their object forms
           NATIVE : values will be stored in non-heap region of JVM
        -->
        <in-memory-format>BINARY</in-memory-format>

        <!--
            Number of backups. If 1 is set as the backup-count for example,
            then all entries of the map will be copied to another JVM for
            fail-safety. 0 means no backup.
        -->
        <backup-count>1</backup-count>
        <!--
            Number of async backups. 0 means no backup.
        -->
        <async-backup-count>0</async-backup-count>
        <!--
			Maximum number of seconds for each entry to stay in the map. Entries that are
			older than <time-to-live-seconds> and not updated for <time-to-live-seconds>
			will get automatically evicted from the map.
			Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 0.
		-->
        <time-to-live-seconds>0</time-to-live-seconds>
        <!--
			Maximum number of seconds for each entry to stay idle in the map. Entries that are
			idle(not touched) for more than <max-idle-seconds> will get
			automatically evicted from the map. Entry is touched if get, put or containsKey is called.
			Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 0.
		-->
        <max-idle-seconds>0</max-idle-seconds>
        <!--
            Valid values are:
            NONE (no eviction),
            LRU (Least Recently Used),
            LFU (Least Frequently Used).
            NONE is the default.
        -->
        <eviction-policy>NONE</eviction-policy>
        <!--
            Maximum size of the map. When max size is reached,
            map is evicted based on the policy defined.
            Any integer between 0 and Integer.MAX_VALUE. 0 means
            Integer.MAX_VALUE. Default is 0.
        -->
        <max-size policy="PER_NODE">0</max-size>
        <!--
            When max. size is reached, specified percentage of
            the map will be evicted. Any integer between 0 and 100.
            If 25 is set for example, 25% of the entries will
            get evicted.
        -->
        <eviction-percentage>25</eviction-percentage>
        <!--
            Minimum time in milliseconds which should pass before checking
            if a partition of this map is evictable or not.
            Default value is 100 millis.
        -->
        <min-eviction-check-millis>100</min-eviction-check-millis>
        <!--
            While recovering from split-brain (network partitioning),
            map entries in the small cluster will merge into the bigger cluster
            based on the policy set here. When an entry merge into the
            cluster, there might an existing entry with the same key already.
            Values of these entries might be different for that same key.
            Which value should be set for the key? Conflict is resolved by
            the policy set here. Default policy is PutIfAbsentMapMergePolicy

            There are built-in merge policies such as
            com.hazelcast.map.merge.PassThroughMergePolicy; entry will be overwritten if merging entry exists for the key.
            com.hazelcast.map.merge.PutIfAbsentMapMergePolicy ; entry will be added if the merging entry doesn't exist in the cluster.
            com.hazelcast.map.merge.HigherHitsMapMergePolicy ; entry with the higher hits wins.
            com.hazelcast.map.merge.LatestUpdateMapMergePolicy ; entry with the latest update wins.
        -->
        <merge-policy>com.hazelcast.map.merge.PutIfAbsentMapMergePolicy</merge-policy>

        <!--
           Control caching of de-serialized values. Caching makes query evaluation faster, but it cost memory.
           Possible Values:
                        NEVER: Never cache deserialized object
                        INDEX-ONLY: Caches values only when they are inserted into an index.
                        ALWAYS: Always cache deserialized values.
        -->
        <cache-deserialized-values>INDEX-ONLY</cache-deserialized-values>

    </map>

    <multimap name="default">
        <backup-count>1</backup-count>
        <value-collection-type>SET</value-collection-type>
    </multimap>

    <list name="default">
        <backup-count>1</backup-count>
    </list>

    <set name="default">
        <backup-count>1</backup-count>
    </set>

    <jobtracker name="default">
        <max-thread-size>0</max-thread-size>
        <!-- Queue size 0 means number of partitions * 2 -->
        <queue-size>0</queue-size>
        <retry-count>0</retry-count>
        <chunk-size>1000</chunk-size>
        <communicate-stats>true</communicate-stats>
        <topology-changed-strategy>CANCEL_RUNNING_OPERATION</topology-changed-strategy>
    </jobtracker>

    <semaphore name="default">
        <initial-permits>0</initial-permits>
        <backup-count>1</backup-count>
        <async-backup-count>0</async-backup-count>
    </semaphore>

    <reliable-topic name="default">
        <read-batch-size>10</read-batch-size>
        <topic-overload-policy>BLOCK</topic-overload-policy>
        <statistics-enabled>true</statistics-enabled>
    </reliable-topic>

    <ringbuffer name="default">
        <capacity>10000</capacity>
        <backup-count>1</backup-count>
        <async-backup-count>0</async-backup-count>
        <time-to-live-seconds>30</time-to-live-seconds>
        <in-memory-format>BINARY</in-memory-format>
    </ringbuffer>

    <serialization>
        <portable-version>0</portable-version>
    </serialization>

    <services enable-defaults="true"/>

    <lite-member enabled="false"/>

</hazelcast>
